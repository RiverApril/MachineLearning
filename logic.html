<html>

<head>
  <script type="application/javascript" src="neuralNetwork.js"></script>
  <script type="application/javascript">
    
    var canvas, context;
    
    var teaching;
    var topology;
    var nn;
    var positions;
    
    var learningRate;
    var epochs;
    var diff;
    
    var fontH = 12;
    var fontO = (fontH/2)-1;
    
    function drawNetwork(network, positions) {
      
      context.fillStyle = "#C0E0FF";
      context.strokeStyle = "#E0C0FF";

      for (var x = 0; x < network.neurons.length; x++) {
        for (var y = 0; y < network.neurons[x].length; y++) {
          context.beginPath();
          context.arc(positions[x][y].x, positions[x][y].y, fontH, 0, Math.PI * 2);
          context.fill();
          if(x > 0){
            context.beginPath();
            for (var k = 0; k < network.neurons[x][y].weights.length; k++) {
              context.moveTo(positions[x][y].x, positions[x][y].y);
              context.lineTo(positions[x-1][k].x, positions[x-1][k].y);
            }
            context.stroke();
          }
        }
      }
      
      
      context.strokeStyle = "#000000";

      for (var x = 0; x < network.neurons.length; x++) {
        for (var y = 0; y < network.neurons[x].length; y++) {
          if(x > 0){
            context.beginPath();
            for (var k = 0; k < network.neurons[x][y].weights.length; k++) {
              var str = network.neurons[x][y].weights[k].toFixed(2);
              var size = context.measureText(str);
              context.strokeText(str, positions[x][y].w[k].x - (size.width / 2), positions[x][y].w[k].y + fontO);
            }
          }
          var str = network.neurons[x][y].data.output.toFixed(2);
          var size = context.measureText(str);
          context.strokeText(str, positions[x][y].x - (size.width / 2), positions[x][y].y + fontO);
        }
      }
      
    }
    
    window.onload = function () {
      'use strict';
      
      canvas = document.getElementById("mainCanvas");
      context = canvas.getContext("2d");
      
      context.canvas.width = window.innerWidth;
      context.canvas.height = window.innerHeight;
      
      context.font = fontH+"px Verdana"

      teaching = [
        {in:[0, 0], out:[0]},
        {in:[0, 1], out:[1]},
        {in:[1, 0], out:[1]},
        {in:[1, 1], out:[0]},
      ];
      
      topology = [2, 2, 1];
      
      nn = new Network(topology);
      
      positions = [];
      for(var p = 0; p < teaching.length; p++){
        positions.push([]);
        var h = context.canvas.height / (teaching.length);
        for (var x = 0; x < nn.neurons.length; x++) {
          positions[p].push([]);
          for (var y = 0; y < nn.neurons[x].length; y++) {
            positions[p][x].push([]);
            positions[p][x][y] = {
              x:(context.canvas.width / nn.neurons.length * (x+1)) - (context.canvas.width / nn.neurons.length / 2), 
              y:(h / nn.neurons[x].length * (y+1)) + (p * h) - (h / nn.neurons[x].length / 2),
              w:[],
            };
            if(x > 0){
              for (var k = 0; k < nn.neurons[x][y].weights.length; k++) {
                var s = {
                  x:(positions[p][x-1][k].x - positions[p][x][y].x),
                  y:(positions[p][x-1][k].y - positions[p][x][y].y),
                };
                var angle = Math.atan2(s.y, s.x);
                var d = Math.sqrt((s.x*s.x) + (s.y*s.y)) / 4;
                var xx = positions[p][x][y].x + (Math.cos(angle) * d);
                var yy = positions[p][x][y].y + (Math.sin(angle) * d);
                positions[p][x][y].w.push({x:xx, y:yy});
              }
            }

          }
        }
      }

      learningRate = 0.2;
      epochs = 0;

      diff = 1;


      var update = function(){
        context.fillStyle = "#FFFFFF";
        context.fillRect(0, 0, context.canvas.width, context.canvas.height);
        
        context.strokeText("Epoch: "+epochs, 0, fontH);
        context.strokeText("Mean Diff: "+diff, 0, fontH*2);
        
        diff = 0;
        for(var set = 0; set < teaching.length; set++){
          nn.calculate(teaching[set].in);
          nn.learn(teaching[set].out, learningRate);
          for (var o = 0; o < teaching[set].out.length; o++) {
            diff = Math.max(Math.abs(nn.neurons[nn.neurons.length - 1][o].data.output-teaching[set].out[o]), diff);
          }
          drawNetwork(nn, positions[set]);
        }
        epochs++;

        //console.log("Epochs: ", epochs);

        //for(set = 0; set < teaching.length; set++){
          //console.log(teaching[set].in, teaching[set].out, nn.calculate(teaching[set].in));
        //}
      
      }
      
      window.setInterval(update, 1);
      
           
    }
    
  </script>
</head>

<body>
  
  <canvas id="mainCanvas" width=400 height=400>Canvas not supported</canvas>
  
</body>

</html>